<img width="846" height="604" alt="image" src="https://github.com/user-attachments/assets/d44bbabb-f3e3-4a00-a25e-50c93c710025" /># PROBLEM
<img width="484" height="754" alt="image" src="https://github.com/user-attachments/assets/34a8889e-e83a-427a-bbcf-620c799c2be0" />


# INTUITION
## TIME COMPLEXITY OF PREVIOUS CODE IS 
<img width="846" height="604" alt="image" src="https://github.com/user-attachments/assets/a503ff1e-07c5-419b-8d93-ed6e03fba646" />

```
- When we are at ith index we want the last (i-k)th index valid
  (such that we can jump from (i-k) to the ith index and it is not possible to jump from before thyat index)
- We want to get the smallest element from { (i-k)th index to the (i-1)th index }
  because those are the valid indices that we can jump to the i'th index
- so we have to use the set, cus there may be a chance that we can have multiple elements.
```

<img width="803" height="346" alt="image" src="https://github.com/user-attachments/assets/795c8eed-33c7-4c13-a129-cf431d505d85" />


![WhatsApp Image 2025-08-24 at 23 25 18_46900a9a](https://github.com/user-attachments/assets/c8fe9cb6-f8dc-4faf-9ccd-ff6ad028a370)


# CODE : Dp + Sorted Set
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

// Macros for cleaner loops
#define fo(i, start, end) for (ll i = start; i <= end; i++)
#define all(x) x.begin(), x.end()

int main() {
    ll n, k;
    cin >> n;   // number of stones
    vector<ll> cost(n + 1, 0);  // cost of each stone (1-based)
    
    cin >> k;  // max jump size
    fo(i, 1, n) cin >> cost[i];

    // dp[i] = minimum cost to reach stone i
    vector<ll> dp(n + 1, LLONG_MAX);
    dp[0] = 0;  // starting point cost = 0

    // Multiset to keep track of last k dp values (sorted)
    multiset<ll> window;
    window.insert(dp[0]);  // initially only dp[0] is available

    fo(i, 1, n) {
        // Minimum dp in the last k steps + cost[i]
        dp[i] = *window.begin() + cost[i];

        // Add this dp[i] into sliding window
        window.insert(dp[i]);

        // Remove dp[i-k] if it's sliding out of the window
        if (i - k >= 0) {
            window.erase(window.find(dp[i - k]));
        }
    }

    cout << dp[n] << endl;  // Answer = min cost to reach stone n
    return 0;
}

```

# RUN HERE
[https://ideone.com/X8MevS](https://ideone.com/UWrSa7)
