âœ… When Stack is Used Here

Because the problem is:
-Greedy: You want to build the "best" result (like lexicographically largest string).
-Order-sensitive: You must keep the relative order of characters.
-And you need to go back and remove past decisions (characters), when you see a better one later.
-A stack is perfect for this because:
-You can easily "undo" past choices (via pop) if you realize a better character comes later.
-You can maintain the correct order by building the answer from left to right (top of the stack is the latest).
-It supports greedy removal in constant time from the end (LIFO).

ğŸ” How to Spot Stack Pattern in Other Problems
Hereâ€™s how you know a stack might be the right tool:
âœ… You must maintain order of elements.
âœ… You sometimes need to remove previous items based on future input.
âœ… You are looking for the "nearest bigger/smaller" element (like in histogram problems).
âœ… Youâ€™re building a result while "compressing" or simplifying a sequence (e.g., removing duplicates, simplifying paths).
âœ… You need to match pairs (like brackets, tags, etc.)

ğŸ” Common Problem Types That Use Stack
Monotonic Stack Problems (e.g. Next Greater Element, Histogram Area)
Greedy + Stack (like this one â€” removing digits/characters to maximize a result)
Balanced Parentheses / Matching Brackets
Infix to Postfix Conversion
Simplifying file paths (../)
Evaluating expressions



âœ… Stack Pattern Cheat Sheet
ğŸ“Œ When to Use a Stack
Ask yourself:
ğŸ” Do I need to track previous elements to make a decision about the current one?
ğŸ§¹ Do I need to remove or undo past choices based on a future value?
ğŸ§­ Is relative order important?
ğŸ§® Am I solving a "nearest bigger/smaller" problem (next greater, previous smaller)?
ğŸ§¬ Do I need to maintain a monotonic sequence (increasing/decreasing)?

ğŸ” Stack Keywords in Problem Statements
If a problem includes:
â€œRemove characters/elements to get the best answerâ€
â€œMaintain order but optimizeâ€
â€œFind previous/next greater/smallerâ€
â€œMatching parentheses/bracketsâ€
â€œSimplify or reduce a path/stringâ€
â€œUndo/redo or simulate memoryâ€

ğŸ”§ Core Stack Actions
| Action    | What It Means                          |
| --------- | -------------------------------------- |
| `push(x)` | Add a new item to the result/structure |
| `pop()`   | Undo last choice if it no longer fits  |
| `top()`   | Compare current item to last kept      |


ğŸ” Real Stack Problem Examples
| Problem                        | Description                         |
| ------------------------------ | ----------------------------------- |
| Remove K Digits                | Greedy removal to minimize number   |
| Largest Rectangle in Histogram | Monotonic stack to compute area     |
| Next Greater Element           | Use stack to track next larger      |
| Valid Parentheses              | Match opening and closing           |
| Simplify Path (Linux-style)    | Collapse "../" or duplicate slashes |

