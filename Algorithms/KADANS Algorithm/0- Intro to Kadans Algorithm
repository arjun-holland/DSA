ğŸ’¡ğŸš€ What is Kadaneâ€™s Algorithm?
Kadaneâ€™s Algorithm is a powerful technique used to find the maximum sum of a contiguous subarray within a 1D array of numbers. It works efficiently in O(n) time, making it ideal for large datasets.

ğŸ” Why It Works â€“ The Intuition
Kadaneâ€™s Algorithm builds on the concept of prefix sums, though it doesnâ€™t store the full prefix sum array.
Instead, it tracks the best sum that ends at each position while iterating through the array.
You donâ€™t need to check all subarrays. Instead, you move forward, always deciding:

â€œShould I continue the current subarray or start fresh at this element?â€
This decision is made using:
        currentSum = max(currentElement, currentSum + currentElement);
You keep updating a global maxSum to store the best answer found so far.

ğŸ§  How It Relates to Prefix Sums
While it's not a direct extension of the prefix sum, the concept is similar:
-Prefix sums store sums from the start to each index.
-Kadaneâ€™s stores the best subarray sum ending at each index, effectively leveraging partial prefix logic dynamically.

In other words, it helps us find:
The maximum subarray ending at index i, by comparing: Just a[i] Or extending the previous best: a[i] + best till i-1

âœ¨ Handles All Cases Gracefully
âœ… All Positive Values:
Just sum the array â€” the entire array is the maximum subarray.

âœ… All Negative Values:
Just pick the least negative element (i.e., the highest number among negatives).

âœ… Mixed Values:
This is where Kadaneâ€™s shines! It efficiently navigates ups and downs to find the best segment.

ğŸ› ï¸ Pseudocode:
int maxSubarraySum(const vector<int>& a) {
    int maxSum = a[0];
    int currSum = a[0];

    for (int i = 1; i < a.size(); ++i) {
        currSum = max(a[i], currSum + a[i]);
        maxSum = max(maxSum, currSum);
    }
    return maxSum;
}

ğŸ’¼ Real-World Applications
Kadaneâ€™s Algorithm is used in many interview and real-life problems, like:
âœ… Amazon Online Assessment questions
ğŸ“ˆ Maximum profit segment in stock price arrays
ğŸ§  Finding best mood streaks in sentiment data
ğŸ” Maximum energy streak in game scores
ğŸ›ï¸ Analyzing best streaks of sales growth

ğŸ”„ Kadane Extensions You Should Know
Find subarray indices (start and end)
Handle 2D arrays (max sum rectangle)
Two non-overlapping subarrays
K-concatenated arrays (Kadane on repeated arrays)
Subarray with max product (variation)

ğŸ“Œ Pro Tip:
Kadaneâ€™s algorithm doesnâ€™t need to store any extra prefix array. It just updates two variables:
â¡ï¸ currentSum: The best sum ending at current index
â¡ï¸ maxSum: The best sum found overall so far

âœ… Final Thoughts
Kadaneâ€™s Algorithm is a go-to method for max subarray problems â€” it's fast, reliable, and works even when the 
array contains only negative numbers. Just remember:
If you're dealing with all negatives, return the max negative element
For mixed arrays, Kadane does its magic automatically
