/*
Problem statement
Ninja was planning to propose to his crush, Nina, with his spectacular martial arts moves. But Nina was more interested in numbers and divisors, so she gave Ninja a challenge to complete. If Ninja solves it, only then she will date him.
Nina gave him an array of positive integers, ‘ARR’ and asked him to find the sum of divisors of the integers in ‘ARR’ with exactly four divisors. In case there is no such integer with exactly four divisors, then the answer is 0. Ninja has been struggling for a very long time, so he needs your help to solve the problem.
Detailed explanation ( Input/output format, Notes, Images )

Constraints:
1 <= T <= 5
1 <= N <= 2000
1 <= ARR[ i ] <= 10 ^ 5

Where ‘T’ is the number of test cases, ‘N’ is the number of integers in the array, ‘ARR’ and ‘ARR[ i ]’ is the ‘i’th element in the ‘ARR’ array.
Time limit: 1 second
Note:
You do not need to print anything, it has already been taken care of. Just implement the given function.
Sample Input 1:
2
4
2 5 6 15
3
4 18 21
Sample Output 1:
36
32
Explanation of Sample Output 1:
Test Case 1 :  
Divisors of 2 are 1 and 2.
Divisors of 5 are 1 and 5.
Divisors of 6 are 1, 2, 3 and 6.
Divisors of 15 are 1, 3, 5 and 15.
Since 6 and 15 have exactly four divisors. Sum of their divisors is (1 + 2 + 3 + 6) + (1 + 3 + 5 + 15) = 36.
*/





#include <bits/stdc++.h> 
using namespace std;

vector<int> primes;            // Global vector to store prime numbers
vector<bool> is_prime(100001, true);   // Boolean array to mark prime numbers using Sieve of Eratosthenes

// Sieve function to precompute all prime numbers up to 100000
void sieve(){
    is_prime[0] = is_prime[1] = false;        // 0 and 1 are not primes

    for(int i = 2; i < 100001; i++){
        if(is_prime[i]){
            primes.push_back(i);              // store the prime number
            for(int j = i * 2; j < 100001; j += i)
                is_prime[j] = false;          // mark all multiples of i as not prime
        }
    }
}

// Helper function to check if a number is prime using binary search
bool isPrime(int x){
    return binary_search(primes.begin(), primes.end(), x);
}

// Main function to compute the sum of divisors for numbers with exactly 4 divisors
int sumFourDivisors(vector<int> &arr, int n)
{
    sieve();           // Precompute primes
    int total = 0;

    for(int e : arr){
        bool found = false;
        for(int p : primes){       // Case 1: Check if the number is product of two distinct primes (e = p * q)
            if(p * p > e) break;       // No need to check further  4*4 > 15
            if(e % p == 0){
                int q = e / p;
                if(q != p && isPrime(q)){      // p and q must be distinct primes
                    total += 1 + p + q + e;    // Sum of divisors: 1, p, q, p*q
                    found = true;
                    break;                 // We only care about the first match
                }
            }
        }
        // Case 2: Check if the number is a cube of a prime (e = p^3)
        if(found == false){
            int r = round(cbrt(e));             // Take cube root and round
            if(r * r * r == e && is_prime[r]){
                total += 1 + r + r * r + e;     // Sum of divisors: 1, r, r^2, r^3
            }
        }
    }
    return total;              // Final result
}

// Main function to handle multiple test cases
int main() {
    int T;
    cin >> T;  // Read number of test cases 
    while (T--) {
        int N;
        cin >> N;  // Number of elements in this test case
        vector<int> arr(N);
        for (int i = 0; i < N; ++i) {
            cin >> arr[i];
        }
        // Call the function and output result
        cout << sumFourDivisors(arr, N) << endl;
    }
    return 0;
}
