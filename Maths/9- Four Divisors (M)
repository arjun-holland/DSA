/*
Problem statement
Ninja was planning to propose to his crush, Nina, with his spectacular martial arts moves. But Nina was more interested in numbers and divisors, so she gave Ninja a challenge to complete. If Ninja solves it, only then she will date him.
Nina gave him an array of positive integers, â€˜ARRâ€™ and asked him to find the sum of divisors of the integers in â€˜ARRâ€™ with exactly four divisors. In case there is no such integer with exactly four divisors, then the answer is 0. Ninja has been struggling for a very long time, so he needs your help to solve the problem.
Detailed explanation ( Input/output format, Notes, Images )

Constraints:
1 <= T <= 5
1 <= N <= 2000
1 <= ARR[ i ] <= 10 ^ 5

Where â€˜Tâ€™ is the number of test cases, â€˜Nâ€™ is the number of integers in the array, â€˜ARRâ€™ and â€˜ARR[ i ]â€™ is the â€˜iâ€™th element in the â€˜ARRâ€™ array.
Time limit: 1 second
Note:
You do not need to print anything, it has already been taken care of. Just implement the given function.
Sample Input 1:
2
4
2 5 6 15
3
4 18 21
Sample Output 1:
36
32
Explanation of Sample Output 1:
Test Case 1 :  
Divisors of 2 are 1 and 2.
Divisors of 5 are 1 and 5.
Divisors of 6 are 1, 2, 3 and 6.
Divisors of 15 are 1, 3, 5 and 15.
Since 6 and 15 have exactly four divisors. Sum of their divisors is (1 + 2 + 3 + 6) + (1 + 3 + 5 + 15) = 36.
*/





#include <bits/stdc++.h> 
using namespace std;

vector<int> primes;            // Global vector to store prime numbers
vector<bool> is_prime(100001, true);   // Boolean array to mark prime numbers using Sieve of Eratosthenes

// Sieve function to precompute all prime numbers up to 100000
void sieve(){
    is_prime[0] = is_prime[1] = false;        // 0 and 1 are not primes

    for(int i = 2; i < 100001; i++){
        if(is_prime[i]){
            primes.push_back(i);              // store the prime number
            for(int j = i * 2; j < 100001; j += i)
                is_prime[j] = false;          // mark all multiples of i as not prime
        }
    }
}

// Helper function to check if a number is prime using binary search
bool isPrime(int x){
    return binary_search(primes.begin(), primes.end(), x);
}

// Main function to compute the sum of divisors for numbers with exactly 4 divisors
int sumFourDivisors(vector<int> &arr, int n)
{
    sieve();           // Precompute primes
    int total = 0;

    for(int e : arr){
        bool found = false;
        for(int p : primes){       // Case 1: Check if the number is product of two distinct primes (e = p * q)
            if(p * p > e) break;       // No need to check further  4*4 > 15
            if(e % p == 0){
                int q = e / p;
                if(q != p && isPrime(q)){      // p and q must be distinct primes
                    total += 1 + p + q + e;    // Sum of divisors: 1, p, q, p*q
                    found = true;
                    break;                 // We only care about the first match
                }
            }
        }
        // Case 2: Check if the number is a cube of a prime (e = p^3)
        if(found == false){
            int r = round(cbrt(e));             // Take cube root and round
            if(r * r * r == e && is_prime[r]){   
                total += 1 + r + r * r + e;     // Sum of divisors: 1, r, r^2, r^3
            }
        }
    }
    return total;              // Final result
}

// Main function to handle multiple test cases
int main() {
    int T;
    cin >> T;  // Read number of test cases 
    while (T--) {
        int N;
        cin >> N;  // Number of elements in this test case
        vector<int> arr(N);
        for (int i = 0; i < N; ++i) {
            cin >> arr[i];
        }
        // Call the function and output result
        cout << sumFourDivisors(arr, N) << endl;
    }
    return 0;
}






ğŸš« Why These Cases Work
Only these two patterns generate exactly four positive divisors:
--e = p * q â†’ distinct primes â†’ 4 divisors
--e = p^3 â†’ cube of one prime â†’ 4 divisors
All other forms (like p^2, p*q*r, non-prime bases) result in more or fewer than 4 divisors.
| `e` | Type | Divisors               | Count | Included?  | Sum |
| --- | ---- | ---------------------- | ----- | ---------  | --- |
| 6   | 2Ã—3  | 1, 2, 3, 6             | 4     | âœ…         | 12  |
| 15  | 3Ã—5  | 1, 3, 5, 15            | 4     | âœ…         | 24  |
| 27  | 3Â³   | 1, 3, 9, 27            | 4     | âœ…         | 40  |
| 64  | 4Â³   | 1, 2, 4, 8, 16, 32, 64 | >4    | âŒ         | -   |





whay if i want exactly 5 divisors?


To find numbers with exactly 5 divisors, you need to understand when a number has exactly 5 positive divisors.
Let's explore the math behind it first:
ğŸ§  Mathematical Insight
The number of positive divisors of a number n = pâ‚^a Ã— pâ‚‚^b Ã— ... Ã— pâ‚–^z is:

totalÂ divisors=(a+1)(b+1)...(z+1)
We want this product to be exactly 5.

âœ… Only Way to Get 5 Divisors
The only possible factorization where the number of divisors equals 5 is:

ğŸ”¹ 5 = 4 + 1 â†’ when n = p^4 for some prime p
âœ… n = p^4 has exactly 5 divisors:
1, p, p^2, p^3, p^4

ğŸ§ª Examples:
n = 2^4 = 16 â†’ Divisors: 1, 2, 4, 8, 16 â†’ âœ… (5 divisors)
n = 3^4 = 81 â†’ Divisors: 1, 3, 9, 27, 81 â†’ âœ… (5 divisors)
n = 4^4 = 256 â†’ âŒ 4 is not a prime â†’ Not valid

ğŸ› ï¸ How to Modify Your Code for 5 Divisors
Update the function to check only for 4th powers of primes.

int sumFiveDivisors(vector<int>& arr, int n) {
    sieve(); // primes and is_prime initialized
    int total = 0;

    for (int e : arr) {
        int r = round(pow(e, 1.0 / 4)); // 4th root
        if (pow(r, 4) == e && is_prime[r]) {
            total += 1 + r + r*r + r*r*r + e; // 1 + p + p^2 + p^3 + p^4
        }
    }

    return total;
}
âœ… Sample:
vector<int> arr = {16, 81, 256, 625}; // 2^4, 3^4, 4^4, 5^4
cout << sumFiveDivisors(arr, arr.size()) << endl;
Output:
Copy
Edit
(1 + 2 + 4 + 8 + 16) +
(1 + 3 + 9 + 27 + 81) +
(625 = 5^4 â†’ 1+5+25+125+625) = âœ…
= 31 + 121 + 781 = 933
âš ï¸ Note
Any number that is not the 4th power of a prime will not have exactly 5 divisors.




What if I want exactly 6 divisors?

ğŸ§  Mathematical Insight
The number of positive divisors of a number n = pâ‚^a Ã— pâ‚‚^b Ã— ... is calculated as:

divisorÂ count=(a+1)(b+1)(...)
We want: (a+1)(b+1)... = 6
âœ… Possible Patterns for Exactly 6 Divisors
There are 3 valid combinations of exponents (a+1)(b+1) that give 6:

1. n = pâµ â†’ (a+1 = 6)
Example: 2âµ = 32 â†’ Divisors: 1, 2, 4, 8, 16, 32

2. n = pÂ¹ Ã— qÂ¹ â†’ (2 Ã— 3 = 6 or 3 Ã— 2 = 6)
Example: n = 2 Ã— 3Â² = 18 â†’ Divisors: 1, 2, 3, 6, 9, 18
or n = 2Â² Ã— 3 = 12 â†’ Divisors: 1, 2, 3, 4, 6, 12

3. n = pÂ² Ã— qÂ¹ (or vice versa)
Also valid. Example: 50 = 5Â² Ã— 2 â†’ Divisors: 1, 2, 5, 10, 25, 50

ğŸ” In Short, These Formulas Yield Exactly 6 Divisors:
| Form         | Type                               | Example |
| -------------| --------------------------------   | ------- |
| p^5          | One prime to the 5th power         | 32      |
| p^2 * q      | Two distinct primes, one squared   | 50      |
| p * q^2      | Two distinct primes, other squared | 18      |


âœ… C++ Implementation to Find Sum of Divisors of Numbers with Exactly 6 Divisors
int sumSixDivisors(vector<int>& arr, int n) {
    sieve(); // Prepare primes and is_prime
    int total = 0;

    for (int e : arr) {
        set<int> divisors;

        // Try all numbers up to sqrt(e)
        for (int i = 1; i * i <= e; ++i) {
            if (e % i == 0) {
                divisors.insert(i);
                divisors.insert(e / i);
            }
        }

        if (divisors.size() == 6) {
            total += accumulate(divisors.begin(), divisors.end(), 0);
        }
    }

    return total;
}
ğŸ§ª Example:
For input:
vector<int> arr = {12, 18, 32, 50}; // 12=2^2*3, 18=2*3^2, 32=2^5, 50=5^2*2
All have 6 divisors, so sum:

12 â†’ 1+2+3+4+6+12 = 28

18 â†’ 1+2+3+6+9+18 = 39

32 â†’ 1+2+4+8+16+32 = 63

50 â†’ 1+2+5+10+25+50 = 93
Total = 223



